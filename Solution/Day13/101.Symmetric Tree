Description: åˆ¤æ–­ä¸€ä¸ªäºŒå‰æ ‘æ˜¯ä¸æ˜¯å…³äºè‡ªèº«å¯¹ç§°çš„ã€‚

Solution 1 : å¯ä»¥è®¾è®¡ä¸€ä¸ªfunction,è¾“å…¥å·¦å³èŠ‚ç‚¹ï¼Œå¦‚æœä¸ºç©ºï¼Œåˆ¤æ–­æ˜¯å¦éƒ½ä¸ºç©ºï¼Œéƒ½ä¸ä¸ºç©ºçš„æƒ…å†µä¸‹ï¼Œåˆ¤æ–­æ˜¯å¦valç›¸ç­‰ï¼Œä¸ç›¸ç­‰ç›´æ¥è¿”å›false,ç›¸ç­‰çš„è¯å°±è¿›è¡Œé€’å½’ï¼Œè¿™é‡Œé€’å½’çš„ä¸¤ä¸ªèŠ‚ç‚¹è¦æ³¨æ„æ˜¯left.leftå’Œright.rightæ¯”è¾ƒï¼Œleft.rightä¸right.leftæ¯”è¾ƒã€‚è¿”å›è¿™ä¸¤å¯¹èŠ‚ç‚¹çš„&&ç»“æœã€‚


public boolean isSymmetric(TreeNode root) {
       return(root==null||isSymmetrichelper(root.left,root.right));
    }
    public boolean isSymmetrichelper(TreeNode left, TreeNode right){
        if(left==null||right==null)
            return left==right;
        if(left.val!=right.val)
            return false;
        return isSymmetrichelper(left.left,right.right)&&isSymmetrichelper(left.right,right.left);
    }
 Â  Â 
Solution 2 : stack Iterative. Â  whileå¾ªç¯å¤–çš„éƒ½æ˜¯å¾ˆå®¹æ˜“æ˜ç™½ï¼Œåˆæ¬¡è¿›å…¥whileå¾ªç¯çš„åˆå§‹çŠ¶æ€åº”è¯¥æ˜¯rootçš„å·¦å³å­æ ‘éƒ½å·²ç»pushè¿›äº†stackï¼Œåœ¨whileä¸­å¼¹å‡ºå¯¹è¡¬ä½ç½®çš„left,rightå,ä½¿ç”¨å’Œwhileä¹‹å¤–å¤„ç†left,rightçš„ç›¸åŒçš„æ–¹æ³•,ç„¶ååˆ†åˆ«å¤„ç†(left.left,right,right)å’Œï¼ˆleft.right,right,leftï¼‰



public boolean isSymmetric(TreeNode root) {
    if(root==null)  return true;
    
    Stack<TreeNode> stack = new Stack<TreeNode>();
    TreeNode left, right;
    if(root.left!=null){
        if(root.right==null) return false;
        stack.push(root.left);
        stack.push(root.right);
    }
    else if(root.right!=null){
        return false;
    }
        
    while(!stack.empty()){
        right = stack.pop();
        left = stack.pop();
        if(right.val!=left.val) return false;
        
        if(left.left!=null){
            if(right.right==null)   return false;
            stack.push(left.left);
            stack.push(right.right);
        }
        else if(right.right!=null){
            return false;
        }
            
        if(left.right!=null){
            if(right.left==null)   return false;
            stack.push(left.right);
            stack.push(right.left);
        }
        else if(right.left!=null){
            return false;
        }
    }
    
    return true;
}



ä½¿ç”¨stackç›¸å½“äºæ·±åº¦éå†ï¼Œå¦‚æœæ­¤é¢˜ç”¨queueå°±æ˜¯å¹¿åº¦éå†

Solution 3 : queue iterative(è¿™ä¸ªæ˜¯æ€è·¯æœ€æ¸…æ™°çš„)



public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root.left);
        queue.offer(root.right);
        while(!queue.isEmpty()){
            TreeNode left = queue.poll();
            TreeNode right = queue.poll();
 Â  Â  Â  Â  Â   if(left == null && right == null) continue; Â  Â  Â  Â   //å¯¹ç§°ä½ç½®éƒ½null ğŸ‘Œ
 Â  Â  Â  Â  Â   if(left == null || right == null) return false; Â  Â  // æ‰§è¡Œåˆ°è¿™æ­¥æ—¶å·²ç»æ’é™¤äº†éƒ½ä¸ºnullçš„å¯èƒ½ï¼
 Â  Â  Â  Â  Â  if(left.val != right.val) return false;
 Â  Â  Â  Â  Â   queue.offer(left.left); Â  Â   //è¿™å››æ­¥è¦å°¤å…¶æ³¨æ„å¯¹åº”ä½ç½®çš„è¦åœ¨ä¸€èµ·offer!!!!
 Â  Â  Â  Â  Â  queue.offer(right.right);
            queue.offer(left.right);
            queue.offer(right.left);
            
        }
        return true;
        
    }
 Â 
